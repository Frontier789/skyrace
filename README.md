# Skyracing
Created by Mátyás Komáromi as an assignment for the Computer Graphics class at University of Trento in fall semester of 2019

![Image](https://frontier711.com/data/drift.png)

## Usage
`skyrace`: launch the autonomous demo.
`skyrace race`: the user is in control of a car.

OpenGL 4.4 is required for the app to run.

The project can be built using cargo, just invoke `cargo build`, see the section on [Compilation and Environment](Compilation-and-environment). The app might take some seconds to load.

The `images`, `models`, `shaders` and `sounds` folders contain resources used to render the 3D application. 
If the app is unable to load any of the resources an error is printed on the console and it quits. 
`race_track.json` is used to store the layout of the racing track.

Launching the application without switches starts an endless loop of AI-driven cars racing.
We can toggle the perspective with `T`. To speed up the movement of the sun, hold `O`.
When launched in autonomous mode, switch between cars by `[` and `]`.
To (un)mute the music, use `M`.

Launching the application with the `-race` switch initializes a car with human driving controller. 
To control the car we can use the buttons `WASD` for throttling, turning left and right, and braking respectively.

## Video
A 3 minute video of the application can be found on [YouTube](https://www.youtube.com/watch?v=Ky0SVXA9AbU&feature=youtu.be)

## Source code
The source code is located in `source` folder, divided into 3 modules, as follows.

| Module | Purpose | LOC |
|--------|---------|-----|
|Glui    |GL Objects, windowing, math, fonts, GUI, ECS|9900|
|Glui_proc    |Derive procedural macros|85|
|Skyrace |The assignment|2100|


#### GLUI
Glui contains object oriented wrappers for handling OpenGL objects, an [Entity-Component-System](https://en.wikipedia.org/wiki/Entity_component_system) (ECS) implementation and it is integrated with windowing capabilities built on [glutin](https://github.com/rust-windowing/glutin). 
Glui also contains math structs such as vectors, matrices and splines and camera controlling utilities.
It features a Graphical User Interface kit built on OpenGL from scratch.
Font loading is done by [rusttype](https://github.com/redox-os/rusttype) via a wrapper.
My initial goal with Glui was trying my hands at ECS and Rust, it worked out well and I've decided to base my CG assignment on it.

[Github link](https://github.com/Frontier789/glui)

#### GLUI_PROC
Procedural derive macros for convenient declaration of `Message` and `Component` structs.

[Github link](https://github.com/Frontier789/glui_decl_macro)

#### Skyrace
Skyrace is the main module of the assignment. The solution is divided into systems and components (according to the principles of ECS): 

`CarSystem` is responsible for managing the drawing state of cars and their physical behavior. 
I've implemented the acceleration, turn and brake of the cars in a physically realistic way following 
[This thesis](https://nccastaff.bournemouth.ac.uk/jmacey/MastersProjects/MSc12/Srisuchat/Thesis.pdf) and
[This github page](https://github.com/spacejack/carphysics2d).
Cars cannot interact, and only move in 2D, but they have realistic suspension.
The cars share a common geometry and are drawn with a Phong shading model.
The car model was way too high-poly so I reduced the geometry using Blender.

`Terrain` is a system that is responsible for generating and drawing the desert.
A heightmap is generated using the [noise library](https://docs.rs/noise/0.6.0/noise/) and then dampened by `images/level.png`
this way the track will always have a level of zero.
The track shader uses this heightmap to displace the geometry of a tessellated square.
The desert is textured and normal mapped, normals and tangents are generated from the heightmap on initialization.
The desert is drawn with a Phong shading model as well.

`Cacti` is the system that loads and renders cactuses.
The size, orientation and placement are random but deterministic.
The vertex shader places the cacti based on the heightmap generated by `Terrain`.
The shading model uses a texture atlas but only has diffuse and ambient terms.

`Track` generates and renders the racing track. Originally, I used splines to interpolate between control points but that often created sharp turns which splines didn't handle in a pretty way after extrusion.
The final implementation is based on chained quadratic Bézier curves, the control points for which are loaded from
`race_track.json`.
I've created the path based on the [Silverstone F1 Circuit](https://www.f1-fansite.com/f1-circuits/silverstone-circuit/) 
located in Great Britain by fitting Bézier curves by hand on the image of the track.
The rendering of the track is also based on the Phong shading model, this time with color mapping, normal mapping and 
roughness mapping.
I was not satisfied with the white lines of the track so the shader is enhancing the white lines procedurally.
I experimented with procedurally generating the asphalt following [this](https://www.youtube.com/watch?v=Hb81bSTygt4) 
Blender tutorial, however, the Worley noise itself ate up too much (about 25%) of GPU time
(I could've cached it in a texture but then the point of being procedural is gone).
The track is tessellated by extruding the curves along their normals and connecting the three curves with two line strips.

`Sky` renders the sky with the sun. 
The rendering is done by drawing a whole screen quad.
The model is based on a physical model that supposes exactly one bounce of light through the atmosphere and calculates
both Rayleigh and Mie scattering. I first read about this technique in [this blog](https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-4/)
and finally implemented it based on [On this GPU [Gems article](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering?ncid=afm-chs-44270&ranMID=44270&ranEAID=a1LgFw09t88&ranSiteID=a1LgFw09t88-43PnjBcMqtoCI2z4ketvSA)The results, however, had a string banding on low light which I've fixed with dithering in sRGB color space, based 
on [this presentation](http://loopit.dk/banding_in_games.pdf).
The composition and density of the atmosphere (Mie and Rayleigh coefficients) and the direction of the sun can be toggled
on the fly by changing uniform variables.
The sun moves in the game (although pretty slowly), which the lighting of the objects takes into account.
I've read about rendering procedural clouds [here](https://www.guerrilla-games.com/read/nubis-realtime-volumetric-cloudscapes-in-a-nutshell) and 
[here](https://area.autodesk.com/blogs/game-dev-blog/volumetric-clouds/#) and I believe a simple model could've fit in but I lacked time to implement it.
I wanted to include shadows, using shadow mapping (I've used it before) or shadow volumes with stencil buffer rendering but again, lack of time.

`SunMover` simply moves the sun in a circular fashion.

`Sounds` implements the logic of playing music and sounds.
The volume of the engines depends on the distance of the camera and is stereo.
The library I have used for sounds is [Rodio](https://github.com/RustAudio/rodio).
All the sounds are royalty-free music from [here](https://bigsoundbank.com/) or [here](https://www.storyblocks.com/).

`WheelMark` provides the marks which are left on the ground by the car when it turns fast at a wide angle.
I allocate a large buffer and stream quads into it when new marks are formed, the update index loops around and thus erases old marks.

[Github link](https://github.com/Frontier789/skyrace)

## Compilation and environment
The compilation requires a Rust development environment, which you can get [here](https://www.rust-lang.org/).
To compile the project, open a terminal in `source/skyrace` and invoke `cargo run --release`, Cargo will automatically
download dependencies from GitHub and compile them.
The libraries that I use should be cross-platform and thus Skyrace should compile also on Linux distros and MacOS however
I've only tested it on Windows 10. 
OpenGL 4.4 is required because I'm using features such as bindless textures and immutable storage.

#### Hardware
I've developed and tested the program on my personal laptop, a Lenovo Thinkpad T480s with a i7-8650U processor and integrated GPU
Intel UHD Graphics 620.

It runs fine even on battery saver mode (takes a bit longer to start up).

## Acknowledgement
The 3D models are from [CGTrader](https://www.cgtrader.com) and are all royalty-free.
The window handling and context creation are done with the `glutin` crate.
Font loading and atlas texture atlas placement is done with the `rusttype` crate.
Image loading is done with the `image` crate.
Other libraries such as `rand`, `num` and `serde` are also used.
