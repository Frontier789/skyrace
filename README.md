# Skyracing
Created by Mátyás Komáromi as an assignment for Computer Graphics class of University of Trento

![Image](https://frontier711.com/data/drift.png)

## Usage
`skyrace.exe`: launch the autonomus demo.
`skyrace.exe -race`: the user is in control of a car.

OpenGL 4.4 is required for the app to run.

The executables are located in the `binaries` folder. The app might take some seconds to load.

The folders `images`, `models`, `shaders` and `sounds` contain resources used to render the 3D application. 
If the app is unable to load any of the resources an error is printed on the console and it quits. 
`race_track.json` is also needed.

Launching the application without switches starts an endless loop of the AI driven cars racing.
We can toggle the perspective with `T`. To speed up the movement of the sun, hold `O`.
When launched in autonomus mode, switch between cars by `[` and `]`.
To (un)mute the music, use `M`.

Launching the application with the `-race` switch initializes a car with human driving controller. 
To control the car we can use the buttons `WASD` for throttling, turning left and right, and braking respectively.

## Binaries
Windows binaries can be downloaded from my [personal page](https://frontier711.com/data/km_unitn_cg_binaries.zip)
A 3 minute video of the application can be found on [YouTube](https://www.youtube.com/watch?v=Ky0SVXA9AbU&feature=youtu.be)

## Source code
The source code is located in `source` folder.
It contains four modules, which all have been written by myself.

| Module | Purpose | LOC |
|--------|---------|-----|
|Assimp  |Load 3D object files into memory|680|
|Glui    |GL Objects, windowing, math, fonts, GUI, ECS|9900|
|Glui_proc    |Derive procedural macros|85|
|Skyrace |The assignment|2100|

#### Assimp
Assimp is a binding to the core of the C++ [Assimp library](https://www.assimp.org/).
This library is used to load 3D models of the car and cacti.

[Github link](https://github.com/Frontier789/Assimp-rs)

#### GLUI
Glui contains object oriented wrappers for OpenGL objects, an Entity-Component-System (ECS) LINK implementation integrated with windowing built on glutin LINK. 
Glui also contains math structs such as vectors, matrices and splines and camera controlling utilities.
It sports a Graphical User Interface built on OpenGL from scratch.
Font loading is done by rusttype LINK via a wrapper.
My initial goal with Glui was trying my hands at ECS and Rust, it worked out well and I've decided to base assignment on it.

[Github link](https://github.com/Frontier789/glui)

#### GLUI_PROC
Procedural derive macros for convient declaration of `Message` and `Component` structs.

[Github link](https://github.com/Frontier789/glui_decl_macro)

#### Skyrace
Skyrace is the main module of the assignment. The solution is divided into systems and components (according to the principles of ECS): 

`CarSystem` is responsible for managing the drawing state of cars and their physical behaviour. 
I've implemented the acceleration, turn and brake of the cars in a physically realistic way following 
[This thesis](https://nccastaff.bournemouth.ac.uk/jmacey/MastersProjects/MSc12/Srisuchat/Thesis.pdf) and
[This github page](https://github.com/spacejack/carphysics2d).
Cars cannot interact, and only move in 2D. The cars have realistic suspension too.
The cars share a common geometry and are drawn with a Phong shading model.
The car model was way too high-poly so I reduced the geometry using Blender.

`Terrain` is a system that is responsible for generating and drawing the desert.
A heightmap is generated using the [noise library](https://docs.rs/noise/0.6.0/noise/) and then dampened by `images/level.png`
this way the track will have a level of zero.
The track shader uses this heightmap to displace the geometry of a tessellated square.
The desert is textured and normal mapped, normals and tangents are generated from the heightmap on initialization.
The desert is drawn with a Phong shading model too.

`Cacti` is the system that loads and renders cactuses.
The size, orientation and placement is random but deterministic.
The vertex shader places the cacti based on the heightmap generated by `Terrain`.
The shading model uses a texture atlas but only has diffuse and ambient terms (cacti is not specular afterall).

`Track` generates and renders the racing track.
In the first version I've used splines to interpolate between control points but that often created sharp turn which 
splines didn't handle in a pretty way after extrusion.
The final implementation is based on chained quadratic Bézier curves, the control points for which are loaded from
`race_track.json`.
I've created the path based on the [Silverstone F1 Circuit](https://www.f1-fansite.com/f1-circuits/silverstone-circuit/) 
located in Great Britain by fitting Bézier curves by hand on the image of the track.
The rendering of the track is also based on the Phong shadng model, this time with color mapping, normal mapping and 
roughness mapping.
I was not satisfied with the white lines of the track so the shader is enchancing the white lines procedurally.
I experimented with proceduraly generating the asphalt following [this](https://www.youtube.com/watch?v=Hb81bSTygt4) 
Blender tutorial, however the Worley noise itself ate up too much (about 25%) of GPU time
(I could've cached it in a texture but then the point of being procedural is gone).
The track is tessellated by extruding the curves along their normals and connecting the three curves with two line strips.

`Sky` renders the sky with the sun. 
The rendering is done by drawing a whole screen quad.
The model is based on a physical model that supposes exactly one bounce of light through the atmosphere and calculates
both Rayleigh and Mie scattering.
I've first read about this technique in [this blog](https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-4/)
and finally implemented it based on [On this GPU Gems article](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering?ncid=afm-chs-44270&ranMID=44270&ranEAID=a1LgFw09t88&ranSiteID=a1LgFw09t88-43PnjBcMqtoCI2z4ketvSA)
The rsults however had a string banding on low light which I've fixed with dithering in sRGB color space, based 
on [this presentation](http://loopit.dk/banding_in_games.pdf).
The composition and density of the atmosphere (Mie and Rayleigh coefficitents) and the direction of the sun can be toggled
on the fly by changing uniform variables.
The sun moves in the game (although pretty slowly), which the lighting of the objects take into account.
I've read about rendering procedural clouds [here](https://www.guerrilla-games.com/read/nubis-realtime-volumetric-cloudscapes-in-a-nutshell) and 
[here](https://area.autodesk.com/blogs/game-dev-blog/volumetric-clouds/#) and I believe a simple model could've fit in but I laced time to implement it.
I wanted to include shadows, using shadow mapping (I've used it before) or shadow volumes with stencil buffer rendering but again, lack of time.

`SunMover` simply moves the sun in a circular fashion.

`Sounds` implements the logic of playing msuic and sounds.
The volume of the engines depend on the distance of the camera and is stereo.
The library I have used for sounds is [Rodio](https://github.com/RustAudio/rodio).
All the sounds are royalty free music from [here](https://bigsoundbank.com/) or [here](https://www.storyblocks.com/).

`WheelMark` provides the marks which are left on the ground by the car when it turns fast in a wide angle.
I allocate a large buffer and stream quads into it when new marks are formed, the update index loops around and thus erases old marks.

[Github link](https://github.com/Frontier789/skyrace)

## Compilation and environment
The compilation requires a Rust developement environment, which you can get [here](https://www.rust-lang.org/).
To compile the project, open a terminal in `source/skyrace` and invoke `cargo run --release`, Cargo will automatically
download dependencies from Github and compile them.
The libraries that I use should be cross-platform and thus Skyrace should compile also on Linux distros and MacOS however
I've only tested it on Windows 10. 
OpenGL 4.4 is required because I'm using features such as bindless textures and immutable storage.
Since Assimp is used to load models, the dynamic library of Assimp is needed for the application to start.
Windows binaries on my [personal page](https://frontier711.com/data/km_unitn_cg_binaries.zip) contains the windows dll of Assimp.
([Assimp's website](https://www.assimp.org/)).

#### Hardware
I've developed and tested the program on my personal laptop, a Lenovo Thinkpad T480s with a i7-8650U and integrated GPU
Intel UHD Graphics 620.
The runs fine even on battery saver mode (starts sluggishly though).
A bit recent dedicated GPU can easily handle it.

## Acknowledgement
The 3D models are from [CGTrader](https://www.cgtrader.com) and are all royalty-free.
The window handling and context creation is done with the `glutin` crate.
Font loading and atlas texture atlas placement is done with the `rusttype` crate.
Image loading is done with the `image` crate.
Other libraries such as `rand`, `num` and `serde` are also used.
